<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | miqu.me]]></title>
  <link href="http://miqu.me/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://miqu.me/"/>
  <updated>2018-11-21T10:05:53+00:00</updated>
  <id>http://miqu.me/</id>
  <author>
    <name><![CDATA[Miguel Angel QuiÃ±ones]]></name>
    <email><![CDATA[miguel@miqu.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reducing the pain of git bisect with Xcode]]></title>
    <link href="http://miqu.me/blog/2017/01/22/reducing-the-pain-of-git-bisect-with-xcode/"/>
    <updated>2017-01-22T11:49:01+00:00</updated>
    <id>http://miqu.me/blog/2017/01/22/reducing-the-pain-of-git-bisect-with-xcode</id>
    <content type="html"><![CDATA[<p>There&rsquo;s times when you need to investigate regressions in your project, and you don&rsquo;t know have any clue as why something is happening. <a href="https://git-scm.com/docs/git-bisect">Git bisect</a> is the best tool for this cases, but it can be painful to use in non small projects using CocoaPods and Xcode. I want to share what I&rsquo;ve been doing to ease the pain.</p>

<!-- more -->


<p>If you never used Git bisect, check this <a href="https://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git">introduction</a>. The git command performs a <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a> across your repository history, starting from two known commits you provide to the algorithm: &lsquo;Good&rsquo; and &lsquo;Bad&rsquo;. &lsquo;Bad&rsquo; will usually be your last commit, and &lsquo;Good&rsquo; will be a commit back in the history of your repository, when you know the code was working as expected. For every step of the search you need to tell git if a commit is good or bad, either manually or automatically by running a script.</p>

<h1>Pain points</h1>

<p>When we enter the realm of iOS development, there&rsquo;s a some factors that make bisect tedious to use.</p>

<p>If you use CocoaPods, and if you don&rsquo;t check in the &lsquo;Pods&rsquo; directory in source control, every time you change branch or bisect selects a new commit, you might need to run <code>pod install</code> in order to have all dependencies available and compile correctly.</p>

<p>If you are searching for a regression, chances are you don&rsquo;t have an automated test suite, so you&rsquo;ll need to run your app manually and reproduce the issue you are searching for. There will be cases when you&rsquo;re dealing with a bug that needs an app reinstall or needs to run on device to reproduce. To top all this, Xcode will start the long indexing process every time there&rsquo;s changes to the sources due to change of commit, so your computer will start doing lot of work.</p>

<p>All of these nuances makes the process of searching for issues using bisect very tedious and not so &lsquo;magical&rsquo; as it is supposed to be. I&rsquo;ve nevertheless used bisect many times to save time otherwise wasted reading code and navigating breakpoints during long debugging sessions. You just need some patience and the will to automate some stuff.</p>

<h1>Reducing the pain</h1>

<h2>Automate pod install</h2>

<p>If you don&rsquo;t check in the &lsquo;Pods&rsquo; directory in source control, you might want to run <code>pod install</code> after every bisect step, to refresh all dependencies. Make use of git&rsquo;s <code>post-checkout</code> <a href="https://git-scm.com/docs/githooks">hook</a> and just perform the operation automatically. I like to close Xcode while updating pods so it doesn&rsquo;t turn crazy and slows down computer even more than usual:</p>

<pre><code class="bash">#!/bin/sh
# Script for .git/hooks/post-checkout
set -e
osascript -e 'quit app "Xcode"'
pod install
open -a Xcode
</code></pre>

<p>After you say &lsquo;good&rsquo; or &lsquo;bad&rsquo;, bisect chooses another commit, and automatically close Xcode, update dependencies and open Xcode again. You can be more sophisticated and open the current project directly. See this <a href="https://github.com/robbyrussell/oh-my-zsh/blob/57fcee0f1c520a7c5e3aa5e2bde974154cdaf0c3/plugins/xcode/xcode.plugin.zsh">example</a>.</p>

<h2>Automate build and run</h2>

<p>As I&rsquo;ve mentioned before, if you end up doing a bisect in the codebase you don&rsquo;t have unit tests covering the issue, or any other kind of regression suite covering the issue. You&rsquo;ll need to manually run the project and reproduce the bug. You can still automate the building and running, so you just need to wait to reproduce, and tell git if the commit was good or bad.</p>

<p>Combine <code>xcodebuild</code> with <a href="https://github.com/phonegap/ios-sim">ios-sim</a> in a <code>post-checkout</code> script:</p>

<pre><code class="bash">#!/bin/sh
set -e
xcodebuild -arch x86_64 -sdk iphonesimulator10.2 -derivedDataPath ".build" -scheme myScheme

ios-sim launch --devicetypeid com.apple.CoreSimulator.SimDeviceType.iPhone-6-Plus .build/Build/Products/Debug-iphonesimulator/myapp.app
</code></pre>

<p>Here we force a simulator-only build and run it straight away so you can do your painful manual testing. You can combine the update of dependencies to just leave reproducing the issue and feedback as manual steps in the process.</p>

<h2>Repository discipline</h2>

<p>In order to be able to bisect faster and achieve meaningful results there&rsquo;s some practices to follow in your commits:</p>

<ul>
<li><strong>Granular commits are better</strong>: Smaller commits will make results of bisect more useful as the commit will have small changes, and will be easier to determine the source of the problem.</li>
<li><strong>Ensure every commit compiles</strong>: It will make a potential bisect easier by not struggling with commits that need to be fixed before tested</li>
<li><strong>Check in CocoaPods</strong>: There&rsquo;s many <a href="https://www.dzombak.com/blog/2014/03/including-pods-in-source-control.html">advantages some disadvantages</a> of keeping Pods in the repository. And one advantage will be the code compiles as-is without need of fetching dependencies.</li>
<li><strong>Write meaningful commits</strong>: This should be general practice in the team, but a meaningful commit might tell you what went wrong without even looking at the code, and will help teammates understand your changes.</li>
</ul>


<h1>Use bisect</h1>

<p>Everybody makes mistakes, and there will be the time when you&rsquo;ll be the one tasked to find out why something is not working, with no clue whatsoever of why. This is the time to think about using <code>git bisect</code>. It can be tedious under iOS projects, but you can ease the pain by automating some bits of the process and some patience.</p>

<p>And if you find finally find a commit of your 1-month younger self, you&rsquo;ll thank yourself if you wrote a meaningful commit message.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Controlling time in the app]]></title>
    <link href="http://miqu.me/blog/2016/10/26/controlling-time-in-the-app/"/>
    <updated>2016-10-26T18:38:37+00:00</updated>
    <id>http://miqu.me/blog/2016/10/26/controlling-time-in-the-app</id>
    <content type="html"><![CDATA[<p>Today I want to share a small utility we&rsquo;ve been using for a while at <a href="http://www.peak.net">Peak</a>, my current workplace, to control the system time inside the application and save time while testing or debugging.</p>

<!-- more -->


<p>In most application code you&rsquo;ll eventually end up with tasks that need to execute periodically, or after some time has passed.  The period of time will depend on the actual application requirements, and might change from the order of seconds to days. For example, you might have a data cleanup every 30 days, your application might ping a backend for synchronization every 10 minutes, or by the start of every day, some data needs to be generated and presented to the user.</p>

<h2>Foundation and dates</h2>

<p>You&rsquo;ll eventually use <code>NSDate</code> and <code>NSCalendar</code> (or <code>Date</code> and <code>Calendar</code> in Swift) to calculate when your tasks should be executed. As an example, say you have a task scheduler, and it will run tasks after a specific amount of time passed:</p>

<pre><code class="swift">protocol Task {
  func execute()
}

class Scheduler {
  func schedule(_ task: Task, every: TimeInterval) {
    // Schedule and save task to run every x seconds
  }

  func run(with date: Date) {
    // Actually perform the calculations and fire due tasks
  }
}
</code></pre>

<p>For this code to be testable it&rsquo;s a very common practice to pass the <code>Date</code> in, as we do in the example above. This will improve testability as the date can be controlled from unit tests, thus isolating the system date from the date the component uses to operate.</p>

<p>But what about the times when you want to check the integration between the code and the system date? What if you want to trigger code that reacts to <code>UIApplicationSignificantTimeChange</code>?</p>

<p>The traditional way to test this kind of interactions is to change the date on the device, be it on iOS directly, or you or computer if running the simulator. But it would be very useful to control the system date and time inside the application without having to change the system date in the device or your computer.</p>

<h2>Time travel</h2>

<p>To control the time from a debugging menu in the application, we used a library called <a href="https://github.com/tuenti/TUDelorean">TUDelorean</a>. This library does some runtime method substitutions to trick any user of <code>Date</code> to a date that is no longer tied to the system, but controlled by us. This class is intended to used for unit tests, and that&rsquo;s how I&rsquo;ve used it in the past. But you can also use it inside your app for testing purposes, and offset the time all the code, even system code, sees.</p>

<p>You can build a small in-app debugging menu where you can specify the amount of time to move from the system date, and trigger the update through the library while you run the app.</p>

<p>Shifting the time is very easy:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">futureDate</span><span class="p">:</span> <span class="n">Date</span> <span class="c1">// Calculate your future date here&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">TUDelorean</span><span class="p">.</span><span class="n">timeTravel</span><span class="p">(</span><span class="nl">to</span><span class="p">:</span> <span class="n">futureDate</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>After this, any code calling <code>Date</code> will be handled a fake date not tied to the system anymore. If you build this testing facility, you can also trigger events on behalf of the system, just to test your assumptions. For example, if you move your date a day forward, you can emit <code>UIApplicationSignificantTimeChange</code> as if a real new day passed in the system clock. This is very useful because you&rsquo;ll be able to test integrations otherwise impossible from unit tests.</p>

<p>When you&rsquo;re done with testing, and want to return to your &lsquo;current&rsquo; system date, just reset it with the provided method:
<code>swift
TUDelorean.backToThePresent()
</code></p>

<h2>Conclusion</h2>

<p>Using a tool designed for unit tests, you can build a small utility that can make your day to day development tasks more effective and less tedious. Here we looked at how controlling the time while running your application is useful, and we used a <a href="https://github.com/tuenti/TUDelorean">library</a> designed for use in unit tests for our in-app debugging usage.</p>

<p>I hope you find this as useful as we&rsquo;ve found it. Suffice to say that it should not be used for more than testing and debugging.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 8: New build settings and analyzer improvements]]></title>
    <link href="http://miqu.me/blog/2016/07/31/xcode-8-new-build-settings-and-analyzer-improvements/"/>
    <updated>2016-07-31T20:50:16+00:00</updated>
    <id>http://miqu.me/blog/2016/07/31/xcode-8-new-build-settings-and-analyzer-improvements</id>
    <content type="html"><![CDATA[<p>I always like to check the new build settings and analyzer improvements of every Xcode release. And this year&rsquo;s main release includes a couple of goodies. Let&rsquo;s check them out!</p>

<!-- more -->


<h1>Analyzer improvements</h1>

<p>From the current Xcode 8 beta 3 <a href="http://adcdownload.apple.com/Developer_Tools/Xcode_8_beta_3/Release_Notes_for_Xcode_8_beta_3.pdf">release notes</a>:</p>

<h2>&lsquo;Misuse of null&rsquo; or CLANG_ANALYZER_NONNULL</h2>

<blockquote><p>The static analyzer check for nullability violations supports both aggressive and less aggressive levels
of checking. The more aggressive level checks for nullability violations in all calls</p></blockquote>

<p>This is a very nice addition for anybody dealing with <em>legacy</em> Objective-C code and audited APIs. So remember to enable the more aggressive setting in your project as it won&rsquo;t be enabled after your upgrade.</p>

<p>Most likely you&rsquo;ll find that some APIs were not used correctly, and you&rsquo;ll get more warnings. You should set it to <code>YES</code> instead of <code>YES_NONAGRESSIVE</code> for the most strict checking.</p>

<p>Remember you can revert (hopefully temporarily) to <code>YES_NONAGRESSIVE</code> so you can make your code compile while you audit the analyzer warnings again.</p>

<h2>New setting: CLANG_ANALYZER_OBJC_DEALLOC</h2>

<blockquote><p>The clang static analyzer now checks for improper cleanup of synthesized instance variables in
-dealloc methods</p></blockquote>

<p>Possibly a minor one, but remember that the analyzer could give you new false positives in legacy code. I couldn&rsquo;t make it trigger in a test project, so I don&rsquo;t really know what it will warn you about.</p>

<h1>New build settings</h1>

<h2>New setting: SWIFT_ACTIVE_COMPILATION_CONDITIONS</h2>

<blockquote><p>âActive Compilation Conditionsâ is a new build setting for passing conditional compilation flags to
the Swift compiler.</p></blockquote>

<p>Previously, we had to declare your conditional compilation flags under <strong>OTHER_SWIFT_FLAGS</strong>, remembering to prepend &ldquo;-D&rdquo; to the setting. For example, to conditionally compile with a <code>MYFLAG</code> value:</p>

<pre><code class="swift">#if MYFLAG
// do stuff
#endif
</code></pre>

<p>The value to add to the setting <code>-DMYFLAG</code></p>

<p>Now we only need to pass the value <code>MYFLAG</code> to the new setting. Time to move all those conditional compilation values!</p>

<h2>New settings: SWIFT_SUPPRESS_WARNINGS and SWIFT_TREAT_WARNINGS_AS_ERRORS</h2>

<blockquote><p>Two new build settings have been added to enable Swift compiler options: -suppress-warnings
(SWIFT_SUPPRESS_WARNINGS) and -warnings-as-errors (SWIFT_TREAT_WARNINGS_AS_ERRORS).</p></blockquote>

<p>Given the compiler will emit warnings, specially during transition periods to future versions of the language, it&rsquo;s a good idea to turn this setting off temporarily. The default value for both is <code>NO</code>, but I&rsquo;m inclined to turn <strong>SWIFT_TREAT_WARNINGS_AS_ERRORS</strong> directly and solve issues straight away.</p>

<h2>EMBEDDED_CONTENT_CONTAINS_SWIFT is deprecated</h2>

<p>Basically this setting has been deprecated. See what it was doing here in the <a href="https://developer.apple.com/library/ios/qa/qa1881/_index.html">Apple technote</a>. You might encounter problems when building your application so it&rsquo;s worth upgrading to the new setting if you are using it.</p>

<blockquote><p>The new build setting ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES replaces the use of
EMBEDDED_CONTENT_CONTAINS_SWIFT. This setting indicates that Xcode should always embed
Swift standard libraries in a target for which it has been set, whether or not the target contains Swift
code.</p></blockquote>

<p>I&rsquo;m guessing these are changes preparing ahead of a binary compatible Swift 4 release. But otherwise I don&rsquo;t see what the new build setting does differently.</p>

<h1>XCConfig files</h1>

<p>If you&rsquo;re like me and like to use <a href="https://pewpewthespells.com/blog/xcconfig_guide.html">xcconfig files</a> then this new release has some small improvements as well. I&rsquo;m very happy!</p>

<blockquote><p>.xcconfig files support conditional inclusion of other .xcconfig files, using the syntax #include?</p></blockquote>

<p>If you have a use case for this one, please let me <a href="https://twitter.com/miguelquinon">know</a>!</p>

<p>And the last, but not least:</p>

<blockquote><p>Xcode takes build settings set in xcconfig files into account when suggesting updates to your build
settings.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 7.3 analyzer improvements]]></title>
    <link href="http://miqu.me/blog/2016/01/21/xcode-7-dot-3-analyzer-improvements/"/>
    <updated>2016-01-21T20:39:53+00:00</updated>
    <id>http://miqu.me/blog/2016/01/21/xcode-7-dot-3-analyzer-improvements</id>
    <content type="html"><![CDATA[<p>The <a href="https://developer.apple.com/xcode/download/">latest xcode beta</a> is available for downloading. There are many improvements, and the usual problems with stuff that stops working&hellip; Ah the love of Apple for it&rsquo;s developers :). But I want to tell you about a feature that caught my attention: <strong>New analyzer settings!</strong></p>

<h1>New analyzer settings</h1>

<p>From the <a href="http://adcdownload.apple.com/Developer_Tools/Xcode_7.3_beta/Xcode_7.3_beta_Release_Notes.pdf">release notes</a>:</p>

<blockquote><p>The static analyzer warns when nil is returned from a method or function with a nonnull return
type or is passed to a parameter marked nonnull.</p>

<p>The static analyzer checks for common misuses of Objective-C generics.</p>

<p>The static analyzer checks for missing localizability. This check is off by default and can be
enabled by selecting âYesâ for âMissing localizabilityâ in the &lsquo;Static Analyzer - Generic Issuesâ build
settings.</p></blockquote>

<p>There are 3 new settings related to these new features: CLANG_ANALYZER_NONNULL, CLANG_ANALYZER_OBJC_GENERICS  and CLANG_ANALYZER_LOCALIZABILITY.</p>

<h1>CLANG_ANALYZER_NONNULL and CLANG_ANALYZER_OBJC_GENERICS</h1>

<p>Objective-C continues to get some love! Adding into the changes for <a href="http://miqu.me/blog/2015/04/17/adopting-nullability-annotations/">nullability</a> and <a href="http://miqu.me/blog/2015/06/09/adopting-objectivec-generics/">generics</a>, now the analyzer will start to warn you about usage not in line with your annotations. That&rsquo;s very good news, considering that the compiler checks were a bit lacking. Additional kudos because both settings are enabled by default.</p>

<h1>CLANG_ANALYZER_LOCALIZABILITY</h1>

<p>This is an intriguing one. Let&rsquo;s investigate further; Let&rsquo;s say you have some code where you set a string to a label:</p>

<pre><code class="swift">label.text = @"not-localized";
</code></pre>

<p>You&rsquo;ll now get a nice analyzer warning: &ldquo;User-facing text should use localized string macro&rdquo;</p>

<p><img src="/images/posts/user-facing-warning.png" alt="warning1" /></p>

<p>But you won&rsquo;t get a warning when the key is not localized. Like:
<code>swift
label.text = NSLocalizedString(@"not-localized", nil);
</code>
Hey, we can&rsquo;t have everything, but here&rsquo;s my <a href="http://openradar.appspot.com/radar?id=4993758374395904">request for improvement submitted</a>.</p>

<p>Anyway, go ahead and enable these new settings! And use the analyzer!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Transitioning iOS versions]]></title>
    <link href="http://miqu.me/blog/2015/12/14/transitioning-ios-versions/"/>
    <updated>2015-12-14T20:00:25+00:00</updated>
    <id>http://miqu.me/blog/2015/12/14/transitioning-ios-versions</id>
    <content type="html"><![CDATA[<p>Having worked in companies developing their own products, I&rsquo;ve faced many times the problem developers encounter when building iOS applications: Your biggest 3rd party dependency - the OS SDK - is changing under you every year. How does your team deal with this in a maintainable way?</p>

<!-- more -->


<h1>Long-term projects</h1>

<p>Unless you do consulting or freelancing, chances are that you will have to deal repeatedly with evolving code in the same project over the years. Even if you jump from project to project, chances are you land into existing projects where there&rsquo;s some code written some time ago.</p>

<p>In longer projects <a href="https://en.wikipedia.org/wiki/Software_rot">software rot</a> stays and the team needs to deal with it. A successful application will face this earlier than expected, and in the fast-paced market of mobile applications, every year Apple is renovating and ruthlessly changing the  Operating System where our code lives. It requires non-trivial amount of work to keep up with changes, while still delivering improvements and features for our users.</p>

<p>I&rsquo;ve worked in teams where these questions were often raised:</p>

<ul>
<li>How do we keep modernising our code, while maintaining backwards compatibility for our users?</li>
<li>What techniques can be use to keep moving fast, while still supporting older OS versions?</li>
<li>How do we approach throwing away old code using deprecated APIs in a big codebase?</li>
<li>How do we write new code taking into account that we will remove support of an older OS version?</li>
</ul>


<h2>Fragmentation</h2>

<p><a href="http://miqu.me/blog/2015/05/27/fragmentation/">As I wrote before</a>, developers in the Apple ecosystem face a different kind of fragmentation. We&rsquo;re forced to adopt breaking changes every year, or &lsquo;die&rsquo; in the process. Apple forces us to start using new features of the OS, and has a policy of deprecating APIs a lot faster than we like. Instead of supporting a lot of older devices and operating systems, we face many breaking changes every year.</p>

<p>A mobile engineering team should embrace change, knowing they&rsquo;ll need to assign some engineering resources to keep up with code changes required to support new and old OS versions. Otherwise the code will rot faster than expected. (Anybody heard about complete rewrite of a feature just written a year ago?).</p>

<p>Apple recommends maintaining support for the current iOS version and the previous one. At the time of this writing this would be iOS9 and iOS8. Even if your business allows for this rule, you&rsquo;re going to have a transitioning period while you update the application code, and still deliver new features and improvements.</p>

<p>I&rsquo;m going to share with you what in my opinion are best practices to keep up with OS upgrades.</p>

<h1>Transitioning iOS versions gracefully</h1>

<p>I would divide best practices in 3 categories.</p>

<ul>
<li>SDK use</li>
<li>Language: Swift / Objective-C</li>
<li>Maintenance of previous releases</li>
</ul>


<p>Let&rsquo;s review each of them in order.</p>

<h2>SDK use</h2>

<h3>Treat deprecated APIs as errors to resolve</h3>

<p>I think we should always treat warnings as errors, and deprecated API use is no exception. If this is not managed around the release of the new OS version, chances are it will take time for the team to keep up with new API. It&rsquo;s best to modernise code to use newer API in the face of deprecations, than leaving warnings as <em>TODO</em> markers for later.</p>

<h3>At runtime, check for OS versions</h3>

<p>For long time, Apple&rsquo;s <a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/cross_development/Using/using.html#//apple_ref/doc/uid/20002000-1114537-BABHHJBC">recommended</a> way of checking for API existence has been using <code>respondsToSelector</code>, <code>[SomeClass class]</code>, or <code>NSClassFromString</code>. There&rsquo;s several pitfalls related to runtime checks and so many variations depending on what you are checking for. I don&rsquo;t see any benefit at all to check for methods, classes etc. Apple introduced availability checks for Swift this year, acknowledging and improving over the old practice around ObjC&rsquo;s flexibility. I think we should change our practices and check only for OS version in Objective-C.</p>

<p>Starting with iOS 8 you can use <code>NSProcessInfo</code> to accurately fetch the OS version your app is running on. Use it in your macros, and never again check for API availability for <code>NSClassFromString</code>, <code>instancesRespondToSelector</code> etc. I like to use this to &lsquo;mark&rsquo; code, so we can keep removing legacy code paths. See next tip.</p>

<h3>ObjC: Mark legacy code paths with macros</h3>

<p>The problem with maintaining or having exceptions in the code for older versions of the OS, is that in the future that code will be dead, as your team will eventually drop support of that OS version. Say you still support iOS 7 today, and you need to implement use of newer API to convert points from one view coordinate system to another. In iOS8 a new API was introduced, and the previous one was not (yet) deprecated. You might want to migrate to use it when it is available. In swift, you can use <em>availability conditions</em> to check at compile-time:</p>

<pre><code class="swift">if #available(iOS 8, *, *) {
  self.view.convertPoint(.Zero, toCoordinateSpace:anotherView)
} else {
  self.view.convertPoint(CGPointZero, toView:anotherView)
}
</code></pre>

<p>When the time comes to drop iOS8, possibly next year, you&rsquo;ll just search the whole project for <code>#available(iOS8</code> checks, and remove the old branch, and removing the check. This cleans the code and clears it of old checks.</p>

<p>You can do the same with Objective-C, defining a function or macro that will determine the OS version at runtime. Furthermore, there may be times where you need to introduce a workaround in the code, related to an older OS version. It is useful to use the same macro to &lsquo;mark&rsquo; the code so when you stop supporting the older OS version, you just need to check for that marker. For example:</p>

<pre><code class="objc">//Assume you have a macro that determines OS version, like MQG_OSVERSION_IOS7
//Mark the code with the macro, doing nothing, just where you are doing a workaround that needs to
//be reviewed when you drop iOS7 support
{
  (void)MQG_OSVERSION_IOS7;
  // Do your stuff, which only is needed under iOS7, but you still do for all OS versions
  // like implementing a delegate method that is not needed for iOS8 or greater, etc
}
</code></pre>

<h3>Control the number of 3rd party libraries</h3>

<p>Any 3rd party library that your project contains adds a cost to your project. If - most likely <em>when</em> - Apple breaks compatibility with an OS release, the maintainer may not be as fast as you to adapt to changes.</p>

<p>Be mindful of this cost when considering a new library, and always be ready to step in and help the maintainer by pushing changes upstream. If you can&rsquo;t afford to do this, chances are your team will suffer every year when updating all dependencies.</p>

<h2>Objective-C</h2>

<p>Most possibly your project still has lots of Objective-C code. And it&rsquo;s this code that needs special care, as the team will need to continue living with it, even in the face of Swift.</p>

<h3>Modernise all Objective-C code</h3>

<p>If you have such old code still using pre-arc code, please refer to <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">this</a> guide. If you still have pre-2.0 Objective-C code, Xcode has a tool that will let you modernise it in minutes.</p>

<p>There&rsquo;s two important changes to the language since Objective-C 2.0, introduced in 2015; That is the addition of <a href="http://miqu.me/blog/2015/05/27/fragmentation/">nullability annotations</a> and <a href="http://miqu.me/blog/2015/06/09/adopting-objectivec-generics/">lightweight generics</a>.</p>

<p>Be sure to use these features in your new Objective-C code, and change APIs of existing code to annotate it for the use from Swift. It will also make you think about exiting code, and possibly encounter bugs! The most important aspect of doing this is that it will ease using older code from Swift, without the need for a rewrite.</p>

<h3>Rewrites in Swift</h3>

<p>The future of Cocoa development is Swift, and any application-level Objective-C code is destined to die sooner rather than later. If you can afford to slowly rewrite part of your application using Swift, just do it. How to organise rewrites is a subject of a whole new article, so I won&rsquo;t give an opinion on this just now.</p>

<h3>Keep code templates up to date</h3>

<p>It might seem unimportant, but your team should have up to date code templates. With the recent changes to the language, unfortunately Apple has not spent the time to change templates for Objective-C.  I find very annoying that the default templates for Objective-C don&rsquo;t annotate the code with <code>NS_ASSUME_NONNULL_BEGIN</code> and <code>NS_ASSUME_NONNULL_END</code> macros. So if you are still writing with that language it&rsquo;s better your team takes control of all templates and use modern ones.</p>

<h2>Swift</h2>

<p>Swift is changing a lot, but it is <a href="http://swift.org">open source</a>. You can check the roadmap and be ready for adoption from day one, when the new version is released as part of Apple tools.</p>

<p>Not modernising to newer Swift code is not an option. Mainly because there are breaking changes, so it will incur a cost on your development time, which is hopefully returned in developer happiness for using the language - The current state of tooling in Swift makes the experience sometimes slower, so no win there ;).</p>

<p>To keep up to date to Swift developments, be sure that somebody in the development team is following at least to the <a href="https://lists.swift.org/mailman/listinfo/swift-evolution-announce">evolution announce</a> mailing list, and review the <a href="https://github.com/apple/swift-evolution">evolution repository</a>.</p>

<h2>Maintenance of previous releases</h2>

<h3>Continous integration</h3>

<p>In my experience, I&rsquo;ve found that to keep the development speed, the team generally needs to have access to 3 development environments in CI, available for any build:</p>

<ul>
<li>Current stable version of Xcode</li>
<li>Beta version of Xcode</li>
<li>Previous version of Xcode (temporarily)</li>
</ul>


<p>Generally all builds should be scheduled to run against the stable version of Xcode. Apple is moving fast, and there generally is one new beta version of Xcode available. That version may or may not have breaking changes to your project.</p>

<p>Sometimes, the team will find it necessary to build with a previous version of Xcode, for example to be able to deploy a hot fix for an application submitted with it.</p>

<h3>Cocoapods in repository</h3>

<p>Different teams have different approaches to dependencies. If you use cocoapods, most likely you&rsquo;ll want dependencies checked in your repository project. Even though there&rsquo;s disadvantages, the biggest advantage is that you&rsquo;ll be able to build previous releases out of a tag. This helps obviously for maintenance reasons, but also to be able to do git bisect reliably. Take this into consideration when deciding if your dependencies should be checked in the repository.</p>

<h1>Conclusion</h1>

<p>Maintaining software projects is hard, and if you are working with a team with a successful product (you should!), then most likely you&rsquo;ll maintain it over time. I&rsquo;ve shared what I think are good practices to maintain code across different iOS versions, with the minimal effort involved. I hope you find it useful.</p>
]]></content>
  </entry>
  
</feed>
