---
layout: post
title: "Automatic bridging from Swift to Objective-C using Sourcery"
date: 2017-05-21 22:30:00 +0100
comments: true
categories: tools meta-programming swift Objective-C
---

I recently read a [great post][Bridging-post] by [Benjamin Encz][encz] about bridging Swift to Objective-C by creating bridging types that can be exposed to the older language. I wondered if his idea can be improved and automated by use of meta-programming with [Sourcery][Sourcery] by [Krzystof Zablocki][zablocki]. The answer is a very impressive ObjC-like uppercase **YES**.

<!-- more -->

First of all, you should read [Benjamin's post][Bridging-post]. He's proposing to use a bridging class that can be instantiated from Objective-C and Swift because it inherits from `NSObject`, and has special methods to get/set bridged properties.

You can check an example [project][example] and the [template][template].

## About Sourcery

[Sourcery][Sourcery] is a tool to generate code, using your written templates, that uses information from your production code. In other words, it's a tool to do [metaprogramming][meta] in Swift. If you are not familiar with Sourcery I encourage you to go read the documentation and at least understand the simple examples like generating `Equatable` implementations for your types. Getting familiar with [Stencil][stencil], one of the supported template languages is also fundamental.

## Building the template

In this post I'm just going to give an overview of the template and the parts that compose it. The final template is [here][template].

We'll need to generate a new class for every struct that we bridge. In order to opt-in to the feature, we use [phantom types][phantom] as protocols, to mark swift types (structs or enums) that can be bridged to Objective-C. Our template will use this protocol to which types to introspect:
```swift
protocol AutoObjCBridgeable {}
```

So for example, say you have the example code:
```swift
enum CheckoutOption {
    case creditCard(given: Int)
    case paypal(String)
}

struct ShoppingCart  {
    var items: [String]
    var checkoutOption: CheckoutOption?

    init(items: [String], checkoutOption: CheckoutOption? = nil) {
        self.items = items
        self.checkoutOption = checkoutOption
    }
}
```

We just need to adopt the protocol in an extension, and the code will be generated by Sourcery:
```swift
extension ShoppingCart : AutoObjCBridgeable {}
extension CheckoutOption : AutoObjCBridgeable {}
```

For structs, we'll also support an annotation named `enableBridging` for properties. We'll opt in the properties we want to bridge. This will allow you to control which properties are actually bridged. Like so:
```swift
struct ShoppingCart  {
    // sourcery:enableBridging
    var items: [String]
    // sourcery:enableBridging
    var checkoutOption: CheckoutOption?

    init(items: [String], checkoutOption: CheckoutOption? = nil) {
        self.items = items
        self.checkoutOption = checkoutOption
    }
}
```

### Structs vs enums

Structs are straightforward to bridge, as we only need to handle properties. On the other hand, enums are very involved because we need to take care of handling an arbitrary number of associated values. We will then divide the generation into two parts, one loop for enumerations, and one for structs.

```javascript
// Bridging for structs
{% for type in types.implementing.AutoObjCBridgeable|struct %}
{% endfor %}

// Bridging of enums
{% for enum in types.implementing.AutoObjCBridgeable|enum %}
{% endfor %}
```

For structs, we only generate one class that contains the Swift native type. We wrap the type with API to set and get properties. Enumerations, on the other hand, will generate more classes. We will have one for the enumeration itself (initialized with `Any` from Objective-C), and every case will be a separate Objective-C class. This way we can contain all the required associated values.

### Generating code for the Swift API, to receive bridging types

## Conclusion

Automating the generation of complex things like bridging is possible with Sourcery. The template I've written doesn't handle all cases of possible code, for example, the template doesn't handle private properties, doesn't take default values for initializers, we don't forward methods, and it doesn't handle properly structs as associated values of enums. I stopped here on purpose, as this generated code should be temporary until a migration eventually happens. In general, interaction from Objective-C to Swift should be kept to a minimum.

I'm very surprised that such complexity can be automated using Sourcery, and I really love the concept and the tool. If you never used it, it's a very useful addition for your Swift toolbelt.

If you have any feedback, please open an issue in the [example repository][example], or reach me on [twitter][twitter].

[Bridging-post]: http://blog.benjamin-encz.de/post/bridging-swift-types-to-objective-c/
[Sourcery]: https://github.com/krzysztofzablocki/Sourcery
[encz]: https://twitter.com/benjaminencz
[zablocki]: https://twitter.com/merowing_
[meta]: https://en.wikipedia.org/wiki/Metaprogramming
[stencil]: https://github.com/kylef/Stencil
[phantom]: https://www.objc.io/blog/2014/12/29/functional-snippet-13-phantom-types/
[template]: https://github.com/DarthMike/GenerateObjCBridging/blob/master/Templates/AutoObjCBridgeable.stencil
[example]: https://github.com/DarthMike/GenerateObjCBridging
[twitter]: https://twitter.com/miguelquinon
